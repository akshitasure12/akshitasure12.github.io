<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Akshita Sure">

<title>Final Report – GSoC’25 | NumFOCUS | NetworkX</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">GSoC’25 | NumFOCUS | NetworkX</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">Akshita Sure</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/akshitasure12"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text">Github</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a></li>
  <li><a href="#contributions" id="toc-contributions" class="nav-link" data-scroll-target="#contributions">Contributions</a>
  <ul class="collapse">
  <li><a href="#adding-embarassingly-parallel-algorithms" id="toc-adding-embarassingly-parallel-algorithms" class="nav-link" data-scroll-target="#adding-embarassingly-parallel-algorithms">Adding Embarassingly parallel algorithms</a></li>
  <li><a href="#improving-the-timing-script-ref.-pr114" id="toc-improving-the-timing-script-ref.-pr114" class="nav-link" data-scroll-target="#improving-the-timing-script-ref.-pr114">Improving the timing script (ref. PR#114)</a></li>
  <li><a href="#adding-a-should_run-parameter-ref.-pr123" id="toc-adding-a-should_run-parameter-ref.-pr123" class="nav-link" data-scroll-target="#adding-a-should_run-parameter-ref.-pr123">Adding a <code>should_run</code> parameter (ref. PR#123)</a></li>
  <li><a href="#switching-the-default-config-to-networkx-ref.-pr122" id="toc-switching-the-default-config-to-networkx-ref.-pr122" class="nav-link" data-scroll-target="#switching-the-default-config-to-networkx-ref.-pr122">Switching the default config to NetworkX (ref. PR#122)</a></li>
  <li><a href="#implement-mem-mapping" id="toc-implement-mem-mapping" class="nav-link" data-scroll-target="#implement-mem-mapping">Implement mem-mapping</a></li>
  <li><a href="#adding-setup-functions-to-benchmarks-ref.-pr126" id="toc-adding-setup-functions-to-benchmarks-ref.-pr126" class="nav-link" data-scroll-target="#adding-setup-functions-to-benchmarks-ref.-pr126">Adding setup functions to benchmarks (ref. PR#126)</a></li>
  </ul></li>
  <li><a href="#work-links" id="toc-work-links" class="nav-link" data-scroll-target="#work-links">Work links</a>
  <ul class="collapse">
  <li><a href="#prs-opened" id="toc-prs-opened" class="nav-link" data-scroll-target="#prs-opened">PRs opened</a></li>
  <li><a href="#issues-raised" id="toc-issues-raised" class="nav-link" data-scroll-target="#issues-raised">Issues Raised</a></li>
  </ul></li>
  <li><a href="#key-learnings-and-challenges" id="toc-key-learnings-and-challenges" class="nav-link" data-scroll-target="#key-learnings-and-challenges">Key Learnings and Challenges</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#achnowledgements" id="toc-achnowledgements" class="nav-link" data-scroll-target="#achnowledgements">Achnowledgements</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Report</h1>
<p class="subtitle lead">Adding embarassingly parallel algorithms to nx-parallel</p>
  <div class="quarto-categories">
    <div class="quarto-category">gsoc</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Akshita Sure </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p><strong>Mentors: Dan Schult, Aditi Juneja</strong> <br> <strong>Timeline</strong>: <em>May 2025 - August 2025</em></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/static/logo.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="400"></p>
</figure>
</div>
<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>This report summarizes my work during Google Summer of Code 2025 on the nx-parallel project, a parallel backend for NetworkX that leverages joblib to run parallel graph algorithms. My contributions included switching the default configuration to use all available cores, refining documentation, and developing a more reliable timing script to reduce measurement variability. I also improved ASV benchmarks by adding a setup function and introduced a <code>should_run</code> mechanism to decide when the parallel backend should be applied. Additionally, I implemented several embarrassingly parallel algorithms, analyzed their performance speedups, and revisited existing implementations to optimize them further.</p>
<p>For a more detailed discussion of the solution approaches, please refer to my <a href="https://github.com/akshitasure12/networkx-blogs/tree/main/blogs">blogs</a>.</p>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<p>nx-parallel is a backend for NetworkX that speeds up graph algorithms by running them in parallel with joblib. Before the coding phase, I spent time strengthening the project’s foundation. I fixed utility functions like <code>chunks</code>, which had been giving wrong results because of parameter handling issues, and refactored <code>get_all_functions</code> to make it more reliable. I also suggested changing the default configuration so that NetworkX uses all available cores (<code>n_jobs=-1</code>) instead of sticking with joblib’s default (<code>None</code>). These early fixes and adjustments set the stage for the larger developments that came during the coding phase.</p>
</section>
<section id="contributions" class="level1">
<h1>Contributions</h1>
<section id="adding-embarassingly-parallel-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="adding-embarassingly-parallel-algorithms">Adding Embarassingly parallel algorithms</h2>
<p>The primary objective of the project was to implement seven embarrassingly parallel algorithms. By the end of the coding phase, around nineteen such graph algorithms were added to nx-parallel:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>File</th>
<th>Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cluster.py</code></td>
<td><code>triangles</code>, <code>clustering</code>, <code>average_clustering</code></td>
</tr>
<tr class="even">
<td><code>link_prediction.py</code></td>
<td><code>apply_prediction</code><sup>1</sup>, <code>jaccard_coefficient</code>, <code>resource_allocation_index</code>, <code>adamic_adar_index</code>, <code>preferential_attachment</code>, <code>common_neighbor_centrality</code>, <code>cn_soundarajan_hopcroft</code>, <code>ra_index_soundarajan_hopcroft</code>, <code>within_inter_cluster</code></td>
</tr>
<tr class="odd">
<td><code>harmonic.py</code></td>
<td><code>harmonic_centrality</code></td>
</tr>
<tr class="even">
<td><code>neighbor_degree.py</code></td>
<td><code>average_neighbor_degree</code></td>
</tr>
<tr class="odd">
<td><code>attracting.py</code></td>
<td><code>number_attracting_components</code></td>
</tr>
<tr class="even">
<td><code>connected.py</code></td>
<td><code>number_connected_components</code></td>
</tr>
<tr class="odd">
<td><code>strongly_connected.py</code></td>
<td><code>number_strongly_connected_components</code></td>
</tr>
<tr class="even">
<td><code>weakly_connected.py</code></td>
<td><code>number_weakly_connected_components</code></td>
</tr>
<tr class="odd">
<td><code>dag.py</code></td>
<td><code>colliders</code>, <code>v_structures</code></td>
</tr>
</tbody>
</table>
<p><sup>1</sup> <em>A private parallel helper function that applies each internal prediction function used by the link prediction algorithms across multiple cores.</em></p>
<p>Working with these algorithms gave me the chance to explore a wide range of challenges in parallel graph computation. Along the way, I gained insight into why some algorithms achieve significant speedups while others do not. For example, certain algorithms scale well on sparse graphs but lose their performance advantage on denser graphs due to the overhead of serializing graph data and distributing work across multiple processes. In other cases, speedup slows down as the number of nodes increases because the overhead of chunking tasks, pickling/unpickling, and scheduling workers grows.</p>
<p>I also encountered implementation-specific constraints. Returning generators from within per-chunk functions, for instance, caused issues since generators cannot be pickled for communication between worker processes. Similarly, tuning parameters like <code>max_chunk_size</code> proved crucial– smaller chunks benefited algorithms needing fine-grained load balancing, while larger chunks improved efficiency by reducing scheduling overhead.</p>
<p>These explorations not only deepened my understanding of parallel execution trade-offs in graph algorithms but also helped shape a set of practical guidelines for when and how parallelization in nx-parallel provides the most benefit.</p>
</section>
<section id="improving-the-timing-script-ref.-pr114" class="level2">
<h2 class="anchored" data-anchor-id="improving-the-timing-script-ref.-pr114">Improving the timing script (ref. <a href="https://github.com/networkx/nx-parallel/pull/114">PR#114</a>)</h2>
<p>The earlier timing script produced inconsistent results, sometimes showing decreasing speedups with more nodes or cores. I replaced it with a timeit-based script that repeats measurements and records the minimum runtime, yielding more stable and accurate results. The impact of this change can be seen below:</p>
<p><strong>Old heatmap</strong>:</p>
<p><img src="assets/static/clustering.png" class="img-fluid" style="width:100.0%"></p>
<p><strong>New heatmap</strong>: <img src="assets/static/clustering_new.png" class="img-fluid" style="width:100.0%"></p>
</section>
<section id="adding-a-should_run-parameter-ref.-pr123" class="level2">
<h2 class="anchored" data-anchor-id="adding-a-should_run-parameter-ref.-pr123">Adding a <code>should_run</code> parameter (ref. <a href="https://github.com/networkx/nx-parallel/pull/123">PR#123</a>)</h2>
<p>A <code>should_run</code> parameter was added to control when the parallel backend is used. By default, it activates only when multiple jobs are available, avoiding parallel execution on a single core. Other policies handle cases where parallelism is ineffective– for example, when speedup is consistently low, the graph is very small, or it’s too dense. The appropriate policy is passed via the <code>_configure_if_nx_active</code> decorator, making the backend adaptable and preventing wasted resources in scenarios where parallelism provides little or no benefit.</p>
</section>
<section id="switching-the-default-config-to-networkx-ref.-pr122" class="level2">
<h2 class="anchored" data-anchor-id="switching-the-default-config-to-networkx-ref.-pr122">Switching the default config to NetworkX (ref. <a href="https://github.com/networkx/nx-parallel/pull/122">PR#122</a>)</h2>
<p>Previously, nx-parallel used Joblib’s default (<code>n_jobs=None</code>) and ran on a single core unless explicitly changed. I switched the defaults to NetworkX’s config and set <code>n_jobs = -1</code>, so the config system now uses all available cores automatically. Hence, the change required a thorough update of the documentation to ensure it accurately reflects the new configuration.</p>
</section>
<section id="implement-mem-mapping" class="level2">
<h2 class="anchored" data-anchor-id="implement-mem-mapping">Implement mem-mapping</h2>
<p>To reduce the memory overhead of passing large graphs between processes, I introduced <a href="https://joblib.readthedocs.io/en/latest/parallel.html#working-with-numerical-data-in-shared-memory-memmapping:~:text=shared%20memory%20(memmapping)-,%C2%B6,-By%20default%20the">memmapping</a> for algorithms where the adjacency matrix is first converted to a NumPy array and stored on disk using Joblib. This allows all processes to share the same underlying file segment instead of creating separate in-memory copies, significantly improving efficiency for large graphs. I applied this approach to <code>is_reachable</code> (ref. <a href="https://github.com/networkx/nx-parallel/pull/119">PR#119</a>), but it can be extended to other algorithms as needed.</p>
</section>
<section id="adding-setup-functions-to-benchmarks-ref.-pr126" class="level2">
<h2 class="anchored" data-anchor-id="adding-setup-functions-to-benchmarks-ref.-pr126">Adding setup functions to benchmarks (ref. <a href="https://github.com/networkx/nx-parallel/pull/126">PR#126</a>)</h2>
<p>Introduced a <code>setup</code> function in each benchmark class to handle graph creation and other external computations before timing the algorithm.</p>
</section>
</section>
<section id="work-links" class="level1">
<h1>Work links</h1>
<p>GSoC blogs: <a href="https://github.com/akshitasure12/networkx-blogs/tree/main/blogs">https://github.com/akshitasure12/networkx-blogs/tree/main/blogs</a></p>
<section id="prs-opened" class="level2">
<h2 class="anchored" data-anchor-id="prs-opened">PRs opened</h2>
<p>The table below lists all the PRs I opened during the GSoC coding phase in both the nx-parallel and NetworkX repositories, along with their merge status.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">PR</th>
<th style="text-align: center;">Link</th>
<th style="text-align: right;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">parallel implementation of <code>triangles</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/106">PR#106</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">adding a custom marker to avoid <code>pytest.mark.order</code> warning</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/107">PR#107</a></td>
<td style="text-align: right;"><img src="assets/static/closed.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">refactor <code>chunks()</code> to correctly use <code>n_jobs</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/112">PR#112</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">improve the timing script</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/114">PR#114</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">parallel implementation of <code>number_</code> algorithms</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/117">PR#117</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">modify <code>is_reachable()</code> to use mem-mapping approach</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/119">PR#119</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">optimise <code>is_reachable()</code> in NetworkX</td>
<td style="text-align: center;"><a href="https://github.com/networkx/networkx/pull/8112">PR#8112</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">remove test order dependency via context managers</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/120">PR#120</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">make <code>n_jobs=-1</code> as defualt</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/122">PR#122</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">add <code>should_run</code> functionality</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/123">PR#123</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">parallel implementation of <code>harmonic_centrality</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/124">PR#124</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">optimise harmonic centrality</td>
<td style="text-align: center;"><a href="https://github.com/networkx/networkx/pull/8158">PR#8158</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">refactor ASV benchmarks with setup functions</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/126">PR#126</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">parallel implementation of <code>link_prediction</code> algorithms</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/127">PR#127</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">refactor <code>test_get_functions_with_get_chunks</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/128">PR#128</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">update <code>test_get_chunks</code> for new algorithms</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/129">PR#129</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">parallel implementation of <code>clustering</code> and <code>average_clustering</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/130">PR#130</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">uses <code>pytest.raises</code> as context</td>
<td style="text-align: center;"><a href="https://github.com/networkx/networkx/pull/8170">PR#8170</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">parallel implementation of <code>average_neighbor_degree</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/132">PR#132</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">move <code>assign_algorithms</code> outside <code>BackendInterface</code> class</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/133">PR#133</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">parallel implementation of <code>v_structures</code> and <code>colliders</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/134">PR#134</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">simplify node selection using <code>nbunch_iter()</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/135">PR#135</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">post merge refinement</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/138">PR#138</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">add <code>should_run</code> for when <code>nodes=None</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/141">PR#141</a></td>
<td style="text-align: right;"><img src="assets/static/open.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">clean up</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/pull/142">PR#142</a></td>
<td style="text-align: right;"><img src="assets/static/open.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
</tbody>
</table>
</section>
<section id="issues-raised" class="level2">
<h2 class="anchored" data-anchor-id="issues-raised">Issues Raised</h2>
<p>The table below summarizes the key issues identified and addressed during the GSoC coding phase in both the nx-parallel and NetworkX repositories, along with their current status.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Issue Description</th>
<th style="text-align: center;">Link</th>
<th style="text-align: right;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>get_all_functions()</code> is not returning args and kwargs of the functions</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/issues/94">PR#94</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Incorrect passing of <code>num_in_chunk</code> as <code>n_jobs</code> in <code>chunks()</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/issues/110">PR#110</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">set <code>n_jobs=-1</code> as default</td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/issues/111">PR#111</a></td>
<td style="text-align: right;"><img src="assets/static/merged.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
<tr class="even">
<td style="text-align: left;">set <code>should_run=False</code> unless <code>nodes</code> is <code>None</code></td>
<td style="text-align: center;"><a href="https://github.com/networkx/nx-parallel/issues/137">PR#110</a></td>
<td style="text-align: right;"><img src="assets/static/open.png" class="img-fluid quarto-figure quarto-figure-center" width="100"></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="key-learnings-and-challenges" class="level1">
<h1>Key Learnings and Challenges</h1>
<p>Reflecting on my GSoC experience, I’m amazed at how much I’ve grown over the course of the program. One of the biggest lessons I’ve learned is the true value of documentation—not just as a formality, but as a way to communicate ideas clearly and leave a record of insights for others (and even for myself in the future). I’ve developed the habit of recording my findings as I go, and over time, I’ve become more mindful about keeping things concise, relevant, and easy to follow.</p>
<p>This journey has also made me naturally more curious. I now find myself constantly asking why something works the way it does and digging deeper to understand it. Alongside that curiosity, I’ve learned the importance of asking questions and seeking clarification from mentors without hesitation. Collaborating in an open-source community has shown me just how valuable discussions are—they not only improve the quality of code but also broaden your perspective on different ways to tackle a problem.</p>
<p>One of the biggest challenges I faced was balancing focus on the defined tasks with the temptation to dive too deeply into side quests. It’s easy to get carried away chasing rabbit holes, but I had to remind myself to stay grounded in the project’s goals while still leaving room for curiosity and experimentation. Finding that balance wasn’t always easy, but it taught me a lot about prioritization and staying organized.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The GSoC 2025 experience has truly been one of a kind. It helped me grow into a more well-rounded developer, going far beyond just “writing code.” Compared to my original proposal, by the end of the summer I had contributed to many more aspects of the project than initially planned. This growth came from becoming increasingly comfortable with the codebase, which gave me the confidence to explore, experiment, and take initiative in new directions. Compared to my original proposal, by the end of the summer I had contributed to many more aspects of the project than initially planned. This growth came from becoming increasingly comfortable with the codebase, which gave me the confidence to explore, experiment, and take initiative in new directions. Looking ahead, I plan to remain an active member of the NetworkX and nx-parallel communities— improving features, and contributing new ideas to advance the project. More importantly, I look forward to continuing the habit of learning, and giving back to the open source community.</p>
</section>
<section id="achnowledgements" class="level1">
<h1>Achnowledgements</h1>
<p>I would like to sincerely thank my mentors, Dan Schult and Aditi Juneja, for their invaluable guidance and support throughout my GSoC journey. Their thoughtful reviews not only helped me refine my work but also encouraged me to pay close attention to even the smallest details. The mid-term review, in particular, was especially insightful, helping me recognize my strengths while highlighting areas for growth and motivating me to continually improve.</p>
<p>I am deeply grateful for their time, patience, and encouragement. I would also like to thank Google Summer of Code for providing me the opportunity to contribute to such an inspiring open-source community and to learn in a collaborative and supportive environment.</p>


</section>

<p>© 2025 Akshita Sure</p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>